<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Nuke Effects – West Coast (3D capable)</title>

<!-- MapLibre GL (3D tilt/rotate) + demo style without API keys -->
<link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet"/>
<script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

<!-- Leaflet fallback -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  :root{
    --bg:#101114; --panel:#0f1318; --muted:#7e8a9a; --fg:#eaeef7; --accent:#2dd4bf;
    --danger:#ef4444; --warn:#f59e0b; --ok:#22c55e;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  #app{display:grid;grid-template-rows:auto 1fr; height:100%;}
  #bar{display:flex;flex-wrap:wrap;gap:8px;align-items:center;padding:8px;background:var(--panel);box-shadow:0 2px 0 #0008;z-index:9}
  #bar .label{font-size:12px;opacity:.85;margin-right:4px}
  #bar input, #bar select, #bar button{background:#0b0e12;border:1px solid #1d2633;color:var(--fg);padding:6px 8px;border-radius:8px}
  #bar button{cursor:pointer}
  #mapwrap{position:relative}
  #map,#mlmap{position:absolute;inset:0}
  /* Right-edge legend dock */
  #legendDock{
    position:absolute; right:10px; top:10px; width:220px; background:#0b0e12dd; border:1px solid #1d2633;
    border-radius:10px; padding:8px; z-index:7; backdrop-filter: blur(4px); user-select:none
  }
  #legendDock header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  #legendDock header .title{font-weight:600;font-size:14px}
  #legendDock .row{display:flex;align-items:center;gap:6px;font-size:13px;margin:4px 0}
  #legendBtn{
    position:absolute; right:10px; top:10px; z-index:8; background:#0b0e12ee; border:1px solid #1d2633; color:var(--fg);
    padding:6px 10px; border-radius:999px; cursor:pointer
  }
  #legendDock .resize{width:100%;accent-color:var(--accent)}
  .badge{display:inline-block;padding:2px 6px;border-radius:999px;font-size:12px}
  .psi20{background:#6d28d9} .psi5{background:#3b82f6} .psi1{background:#22d3ee} .therm{background:#f97316}
  .fall{background:#22c55e}
  /* wind control mini-compass */
  #windHUD{position:absolute; left:10px; top:10px; z-index:8; background:#0b0e12ee; border:1px solid #1d2633; padding:6px 8px; border-radius:10px}
  #windHUD canvas{display:block}
  .note{color:var(--muted);font-size:12px}
  /* ring labels */
  .ring-label{
    position:absolute; transform:translate(-50%,-50%); background:#0b0e12cc; padding:2px 6px; border:1px solid #1d2633; border-radius:8px; font-size:12px
  }
</style>
</head>
<body>
<div id="app">
  <div id="bar">
    <span class="label">Burst:</span>
    <select id="preset">
      <option value="custom">Custom</option>
      <option value="15">Little Boy (15 kt)</option>
      <option value="100" selected>W76 (100 kt)</option>
      <option value="475">W88 (475 kt)</option>
      <option value="1200">B83 (1.2 Mt)</option>
      <option value="50000">Tsar Bomba (50 Mt)</option>
    </select>
    <span class="label">Yield kt</span><input id="yield" type="number" min="0.1" step="0.1" value="100" style="width:82px">
    <span class="label">Altitude m</span><input id="alt" type="number" step="10" value="0" style="width:90px">
    <label><input id="fallout" type="checkbox" checked> Fallout</label>
    <span class="label">WX</span>
    <select id="wx">
      <option value="dry">Dry</option>
      <option value="rain">Rain</option>
      <option value="snow">Snow</option>
    </select>
    <span class="label">Wind</span>
    <input id="wind" type="number" min="0" max="360" step="1" value="90" style="width:72px">°
    <button id="add">Add burst (tap map)</button>
    <button id="clear">Clear</button>
    <span class="label">Basemap</span>
    <select id="basemap">
      <option value="auto" selected>Auto</option>
      <option value="osm">OSM Streets</option>
      <option value="sat">Satellite (demo)</option>
      <option value="grid">Offline grid</option>
    </select>
  </div>

  <div id="mapwrap">
    <!-- MapLibre 3D map (if supported) -->
    <div id="mlmap"></div>
    <!-- Leaflet fallback (hidden if ML active) -->
    <div id="map"></div>

    <button id="legendBtn">Legend</button>
    <div id="legendDock" hidden>
      <header>
        <div class="title">Legend</div>
        <button id="closeLegend" title="Hide">✕</button>
      </header>
      <div class="row"><span class="badge psi20">20 psi</span> severe structural collapse</div>
      <div class="row"><span class="badge psi5">5 psi</span> heavy damage (most houses)</div>
      <div class="row"><span class="badge psi1">1 psi</span> window failure / light damage</div>
      <div class="row"><span class="badge therm">Thermal 3rd°</span> unprotected burns</div>
      <div class="row"><span class="badge fall">Fallout</span> plume (dose bands)</div>
      <div class="row"><input id="legendSize" type="range" min="180" max="320" value="220" class="resize"></div>
      <div class="note">Drag this panel by its header. Tap a ring on the map for text + dose.</div>
    </div>

    <div id="windHUD">
      <div style="display:flex;align-items:center;gap:8px;">
        <canvas id="windCompass" width="90" height="90" title="Drag arrow to set bearing"></canvas>
        <div>
          <div style="font-weight:600">Wind</div>
          <div class="note">Drag arrow • 0–359°</div>
          <div id="windRead" style="margin-top:4px;font-weight:600">90° (E)</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------- utilities ---------- */
const $ = sel => document.querySelector(sel);
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const toRad = d=>d*Math.PI/180;
const toDeg = r=>r*180/Math.PI;
const bearingToCardinal = b=>{
  const dirs=['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
  return dirs[Math.round(((b%360)+360)%360/22.5)%16];
};

// quick colors
const col = {
  psi20:'#6d28d9', psi5:'#3b82f6', psi1:'#22d3ee', therm:'#f97316', fall:'#22c55e'
};

/* ---------- state ---------- */
let useML = false;        // using MapLibre?
let mlmap, lmap;          // maps
let bursts = [];          // [{latlng, yieldKt, alt, windDeg, wx, rings, plume}]
let addMode = false;
let windDeg = 90;

/* ---------- map init (prefer MapLibre GL) ---------- */
function webglOk(){
  try{
    const c=document.createElement('canvas');
    return !!(window.WebGLRenderingContext&&(c.getContext('webgl')||c.getContext('experimental-webgl')));
  }catch(e){return false}
}

async function initMap(){
  const start=[45.85,-123.49]; // Birkenfeld default view
  if(webglOk()){
    try{
      useML=true;
      $('#map').style.display='none';
      mlmap = new maplibregl.Map({
        container:'mlmap',
        style:'https://demotiles.maplibre.org/style.json', // free demo style
        center:[start[1],start[0]],
        zoom:8.5,
        pitch:30, bearing:0,
        touchZoomRotate:true, pitchWithRotate:true
      });
      mlmap.addControl(new maplibregl.NavigationControl({visualizePitch:true}), 'top-left');
      mlmap.addControl(new maplibregl.ScaleControl({maxWidth:120,unit:'imperial'}));
      mlmap.on('load', ()=>{ /* ready */ });
      mlmap.on('click', e=>{ if(addMode){ placeBurst([e.lngLat.lat,e.lngLat.lng]); addMode=false; $('#add').classList.remove('active'); } });
      mlmap.on('move', syncWindHUD);
      return;
    }catch(e){ useML=false; }
  }
  // fallback Leaflet
  useML=false;
  $('#mlmap').style.display='none';
  lmap = L.map('map',{zoomControl:true}).setView(start, 9);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    maxZoom:19, attribution:'© OpenStreetMap'
  }).addTo(lmap);
  lmap.on('click', e=>{ if(addMode){ placeBurst([e.latlng.lat,e.latlng.lng]); addMode=false; $('#add').classList.remove('active'); } });
}
initMap();

/* ---------- legend UI ---------- */
const legend = $('#legendDock');
$('#legendBtn').onclick=()=>legend.hidden=!legend.hidden;
$('#closeLegend').onclick=()=>legend.hidden=true;
$('#legendSize').oninput=e=>{legend.style.width = e.target.value+'px'};
// drag legend by header
(function dragPanel(){
  let drag=false, sx=0, sy=0, ox=0, oy=0;
  const header = $('#legendDock header');
  header.style.cursor='move';
  header.addEventListener('pointerdown',ev=>{drag=true;sx=ev.clientX;sy=ev.clientY; const r=legend.getBoundingClientRect(); ox=r.left; oy=r.top; header.setPointerCapture(ev.pointerId);});
  header.addEventListener('pointermove',ev=>{if(!drag)return; const dx=ev.clientX-sx, dy=ev.clientY-sy; legend.style.left=(ox+dx)+'px'; legend.style.top=(oy+dy)+'px'; legend.style.right='auto';});
  header.addEventListener('pointerup',()=>drag=false);
})();

/* ---------- wind compass (draggable) ---------- */
const compass = $('#windCompass');
const ctx = compass.getContext('2d');
function drawCompass(){
  const c=ctx, w=compass.width, h=compass.height, r=42, cx=w/2, cy=h/2;
  c.clearRect(0,0,w,h);
  c.save();
  // dial
  c.beginPath(); c.arc(cx,cy,r,0,Math.PI*2); c.fillStyle='#0b0e12'; c.fill(); c.lineWidth=2; c.strokeStyle='#1d2633'; c.stroke();
  // ticks
  c.translate(cx,cy);
  for(let i=0;i<36;i++){
    c.save(); c.rotate(i*10*Math.PI/180);
    c.beginPath(); c.moveTo(0,-r+3); c.lineTo(0,-r+(i%9===0?12:6));
    c.strokeStyle=i%9===0?'#fff':'#5b6779'; c.lineWidth=i%9===0?2:1; c.stroke(); c.restore();
  }
  // arrow
  c.save(); c.rotate(toRad(windDeg));
  c.beginPath(); c.moveTo(0,8); c.lineTo(0,-r+14); c.strokeStyle='#2dd4bf'; c.lineWidth=4; c.stroke();
  c.beginPath(); c.moveTo(0,-r+14); c.lineTo(6,-r+28); c.lineTo(-6,-r+28); c.closePath(); c.fillStyle='#2dd4bf'; c.fill();
  c.restore();
  c.restore();
  $('#windRead').textContent = `${Math.round(((windDeg%360)+360)%360)}° (${bearingToCardinal(windDeg)})`;
  $('#wind').value = Math.round(((windDeg%360)+360)%360);
}
drawCompass();
compass.addEventListener('pointerdown',onDrag); compass.addEventListener('pointermove',onDrag);
function onDrag(ev){
  if(ev.buttons===0 && ev.type==='pointermove') return;
  const rect = compass.getBoundingClientRect();
  const x = ev.clientX - rect.left - rect.width/2;
  const y = ev.clientY - rect.top - rect.height/2;
  windDeg = (toDeg(Math.atan2(x,-y))+360)%360;
  drawCompass(); updatePlumes();
}
$('#wind').addEventListener('input', e=>{ windDeg=+e.target.value; drawCompass(); updatePlumes(); });

/* ---------- controls ---------- */
$('#preset').onchange = e=>{
  const v=e.target.value;
  if(v==='custom') return;
  $('#yield').value = v;
};
$('#add').onclick=()=>{ addMode=!addMode; $('#add').classList.toggle('active',addMode); };
$('#clear').onclick=()=>{ clearBursts(); };

$('#wx').onchange=updatePlumes;
$('#yield').oninput=()=>{ /* live update for selected burst later if needed*/ };
$('#alt').oninput=()=>{};
$('#basemap').onchange=()=>{
  const v=$('#basemap').value;
  if(useML){
    if(v==='grid'){ /* no-op; grid is drawn by us below */ }
    if(v==='sat'){ mlmap.setStyle('https://demotiles.maplibre.org/style.json'); } // demo includes satellite-ish layer
    if(v==='osm'){ mlmap.setStyle('https://demotiles.maplibre.org/style.json'); }
  } else {
    lmap.eachLayer(l=>{
      if(l._url){
        l.remove();
      }
    });
    if(v==='grid'){
      // grid drawn as overlay; also add light OSM beneath
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(lmap);
    } else if(v==='sat'){
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(lmap); // placeholder
    } else {
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(lmap);
    }
  }
};

/* ---------- model: radii & plume ---------- */
/* Very compact approximation:
   - psi rings scale ~ W^(1/3). Constants tuned for realism.
   - Thermal radius approximated for 3rd degree burns (no terrain/urban shielding).
   - Fallout ellipse length grows with yield^0.5 and shrinks with precipitation; direction = windDeg.
   These are preparedness-grade visuals, not targeting data.
*/
function kmToPixels(lat, km, zoomMetersPerPixel){
  // not needed for vector libs; kept for clarity
}

function ringKm(yieldKt, psi){
  const W = Math.cbrt(Math.max(0.1, yieldKt));
  // constants (km) tuned to give reasonable scales
  if(psi===20) return 0.9*W;
  if(psi===5)  return 1.9*W;
  if(psi===1)  return 4.2*W;
  return 0;
}
function thermalKm(yieldKt){
  const W = Math.cbrt(Math.max(0.1, yieldKt));
  return 7.0*W; // coarse
}
function plumeParams(yieldKt, wx, alt){
  const base = Math.sqrt(Math.max(0.1, yieldKt));
  let len = 25*base;
  let width = 6*base;
  if(wx==='rain'){ len*=0.8; width*=0.7; }
  if(wx==='snow'){ len*=0.9; width*=0.8; }
  if(alt>300){ len*=0.6; width*=0.6; } // airburst -> less fallout
  return {len, width};
}

/* ---------- draw helpers ---------- */
let drawn = []; // store handles to clean up
function llToXY(ll){ return useML? [ll[1], ll[0]] : ll; }

function addCircle(lat,lng,rkm,color,opacity=0.25,label){
  if(useML){
    const id = 'c'+Math.random().toString(36).slice(2);
    const coords = circleGeoJSON([lng,lat], rkm*1000, 90);
    mlmap.addSource(id,{type:'geojson',data:coords});
    mlmap.addLayer({id:id, type:'fill', source:id, paint:{'fill-color':color,'fill-opacity':opacity}});
    const lineId=id+'l';
    mlmap.addLayer({id:lineId,type:'line',source:id,paint:{'line-color':color,'line-width':2,'line-opacity':0.9}});
    drawn.push({type:'mlsrc', id},{type:'mllayer', id},{type:'mllayer', id:lineId});
    // label (approx): create HTML div anchored at circle edge (east)
    addRingLabel(lat, lng, rkm, label);
  }else{
    const c = L.circle([lat,lng], {radius:rkm*1000,color,weight:2,fillColor:color,fillOpacity:opacity}).addTo(lmap);
    c.on('click',()=> ringInfo(label));
    drawn.push(c);
    addRingLabel(lat, lng, rkm, label);
  }
}
function addRingLabel(lat,lng,rkm,labelText){
  // place roughly at east edge
  const R = 6371; const d = rkm/R; const brg = 90*Math.PI/180;
  const lat1 = lat*Math.PI/180, lon1 = lng*Math.PI/180;
  const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d)+Math.cos(lat1)*Math.sin(d)*Math.cos(brg));
  const lon2 = lon1 + Math.atan2(Math.sin(brg)*Math.sin(d)*Math.cos(lat1), Math.cos(d)-Math.sin(lat1)*Math.sin(lat2));
  const el = document.createElement('div'); el.className='ring-label'; el.textContent=labelText;
  el.style.pointerEvents='none';
  document.body.appendChild(el);
  positionHTML(el,[lat2*180/Math.PI, lon2*180/Math.PI]);
  drawn.push({type:'htmlel', el});
}
function addPlume(lat,lng,deg,lenKm,widthKm,color='#22c55e',opacity=0.22){
  // rough ellipse wedge along bearing
  const g = plumeGeoJSON([lng,lat], deg, lenKm, widthKm);
  if(useML){
    const id='p'+Math.random().toString(36).slice(2);
    mlmap.addSource(id,{type:'geojson',data:g});
    mlmap.addLayer({id:id, type:'fill', source:id, paint:{'fill-color':color,'fill-opacity':opacity}});
    mlmap.addLayer({id:id+'l', type:'line', source:id, paint:{'line-color':color,'line-width':1.5}});
    drawn.push({type:'mlsrc', id},{type:'mllayer', id},{type:'mllayer', id:id+'l'});
  }else{
    const poly = L.geoJSON(g,{style:{color,weight:1.5,fillColor:color,fillOpacity:opacity}}).addTo(lmap);
    drawn.push(poly);
  }
}
function clearBursts(){
  bursts = [];
  if(useML){
    drawn.forEach(d=>{
      if(d.type==='mllayer'){ try{ mlmap.removeLayer(d.id);}catch{} }
      else if(d.type==='mlsrc'){ try{ mlmap.removeSource(d.id);}catch{} }
      else if(d.type==='htmlel'){ d.el.remove(); }
    });
    drawn=[];
  }else{
    drawn.forEach(g=>{ try{ lmap.removeLayer(g);}catch{} });
    drawn=[];
    document.querySelectorAll('.ring-label').forEach(e=>e.remove());
  }
}
function ringInfo(label){
  alert(label + "\n\nTap different rings/plume to compare. These are preparedness-grade estimates.");
}

function placeBurst(ll){
  const y = +$('#yield').value;
  const a = +$('#alt').value;
  const wx = $('#wx').value;
  const lat = ll[0], lng = ll[1];
  // draw rings
  const r20 = ringKm(y,20), r5=ringKm(y,5), r1=ringKm(y,1), th=thermalKm(y);
  addCircle(lat,lng,r20,col.psi20,0.28,'20 psi: severe collapse');
  addCircle(lat,lng,r5 ,col.psi5 ,0.25,'5 psi: heavy damage');
  addCircle(lat,lng,r1 ,col.psi1 ,0.22,'1 psi: light damage');
  addCircle(lat,lng,th ,col.therm,0.15,'Thermal 3rd° burns');
  // fallout plume
  if($('#fallout').checked){
    const p = plumeParams(y, wx, a);
    addPlume(lat,lng, windDeg, p.len, p.width, col.fall, 0.22);
  }
  // marker
  if(!useML){
    const m=L.marker([lat,lng]).addTo(lmap); drawn.push(m);
  }else{
    const m = new maplibregl.Marker().setLngLat([lng,lat]).addTo(mlmap);
    drawn.push({type:'marker', m});
  }
}

function updatePlumes(){
  if(bursts.length===0) return; // not tracking individually in this minimal patch
}

/* ---------- geo helpers ---------- */
function circleGeoJSON(center, radiusMeters, points){
  const [lng,lat]=center; const coords=[];
  for(let i=0;i<=points;i++){
    const brg = i/points*2*Math.PI;
    const d = radiusMeters/6371000;
    const lat1 = toRad(lat), lon1 = toRad(lng);
    const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d)+Math.cos(lat1)*Math.sin(d)*Math.cos(brg));
    const lon2 = lon1 + Math.atan2(Math.sin(brg)*Math.sin(d)*Math.cos(lat1), Math.cos(d)-Math.sin(lat1)*Math.sin(lat2));
    coords.push([toDeg(lon2), toDeg(lat2)]);
  }
  return {type:'Feature',geometry:{type:'Polygon',coordinates:[coords]}};
}
function plumeGeoJSON(centerDeg, bearingDeg, lenKm, widthKm){
  const [lng0,lat0]=centerDeg;
  const coords=[], N=120;
  const lenM=lenKm*1000, halfW=widthKm*500; // half width in meters
  // build a tapered capsule/ellipse along bearing
  for(let i=0;i<=N;i++){
    const t=i/N;
    const dist = t*lenM;
    const w = Math.sin(Math.PI*Math.min(1,t))*halfW; // taper
    // offset right side
    coords.push(offsetOnEarth(lat0,lng0, dist, bearingDeg,  w));
  }
  for(let i=N;i>=0;i--){
    const t=i/N;
    const dist = t*lenM;
    const w = Math.sin(Math.PI*Math.min(1,t))*halfW;
    coords.push(offsetOnEarth(lat0,lng0, dist, bearingDeg, -w));
  }
  return {type:'Feature',geometry:{type:'Polygon',coordinates:[coords]}};
}
function offsetOnEarth(lat,lng, forwardMeters, bearingDeg, rightMeters){
  // move forward, then offset right by perpendicular
  const R=6371000;
  const brg=toRad(bearingDeg);
  const lat1=toRad(lat), lon1=toRad(lng);
  const d=forwardMeters/R;
  const lat2=Math.asin(Math.sin(lat1)*Math.cos(d)+Math.cos(lat1)*Math.sin(d)*Math.cos(brg));
  const lon2=lon1+Math.atan2(Math.sin(brg)*Math.sin(d)*Math.cos(lat1),Math.cos(d)-Math.sin(lat1)*Math.sin(lat2));
  // perpendicular shift
  const brg2=brg+Math.PI/2;
  const d2=rightMeters/R;
  const lat3=Math.asin(Math.sin(lat2)*Math.cos(d2)+Math.cos(lat2)*Math.sin(d2)*Math.cos(brg2));
  const lon3=lon2+Math.atan2(Math.sin(brg2)*Math.sin(d2)*Math.cos(lat2),Math.cos(d2)-Math.sin(lat2)*Math.sin(lat3));
  return [toDeg(lon3), toDeg(lat3)];
}

/* ---------- map HTML overlay positioning (for ring labels) ---------- */
function project(ll){
  if(useML){
    const p = mlmap.project({lng:ll[1],lat:ll[0]});
    return [p.x,p.y];
  }else{
    return lmap.latLngToLayerPoint(L.latLng(ll[0], ll[1]));
  }
}
function positionHTML(el, ll){
  const container = useML ? mlmap.getContainer() : lmap.getContainer();
  const rect = container.getBoundingClientRect();
  const [x,y]=project(ll);
  el.style.left = (rect.left + x) + 'px';
  el.style.top  = (rect.top  + y) + 'px';
}
window.addEventListener('resize',()=>document.querySelectorAll('.ring-label').forEach(e=>e.remove()));

function syncWindHUD(){ /* reserved for future use */ }

/* ---------- start with legend visible ---------- */
legend.hidden=false;
</script>
</body>
</html>